substitutions:
  ## Configuration parameters

  # Cat names to be shown in the Home Assistant UI
  cat1_name: "Cat 1"
  cat2_name: "Cat 2"

  # Timezone of the device, used for daily visits sensors
  # See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
  # for valid values, e.g. "Europe/Bucharest", "America/New_York", "GMT0"
  timezone: "GMT0"

  # Interval in days after which the litter should be changed.
  # Used for the deep clean reminder.
  litter_change_interval: "30" # days

  ## Internal parameters

  # Minimum duration of a clean event to be considered valid and automatically
  # reset the waste and visits counters. Used to distinguish small bumps
  # from actual clean events. Decrease this value if quick cleaning events
  # are not detected.
  min_clean_event_duration: "30" # seconds

  # Duration of no vibration detected before vibration sensor is considered off.
  vibration_off_delay: "4" # seconds

  # Relative weight change between two consecutive readings to consider
  # as vibration. Used to filter out small noise from the weight sensor.
  vibration_threshold: "0.020" # kg

  # Duration of no activity (vibration, cat, or occupancy) detected before
  # the event should be considered over. Compounded with the vibration delay.
  activity_off_delay: "4" # seconds

  # Relative weight change between two consecutive readings to consider
  # as a spurious measurement.
  # Used to filter out big outliers from the weight sensor.
  spike_threshold: "4" # kg

  # Duration of no vibration detected before forcing the event to be over.
  # Used as fallback when weight sensor reads above detection thresholds after
  # a litterbox event.
  inactivity_timeout: "60" # seconds

globals:
  - id: litterbox_weight
    type: float
    initial_value: "0.0" # FIXME: Set to the weight of the empty litterbox
    restore_value: False
  - id: cat1_weight
    type: float
    initial_value: "0.0" # FIXME: Set to the starting weight of the first cat
    restore_value: True
  - id: cat2_weight
    type: float
    initial_value: "0.0" # FIXME: Set to the starting weight of the second cat
    restore_value: True
  - id: cat1_daily_visits
    type: int
    initial_value: "0"
    restore_value: True
  - id: cat2_daily_visits
    type: int
    initial_value: "0"
    restore_value: True

  # No changes necessary below this line
  - id: tare_value
    type: float
    initial_value: "0.0"
    restore_value: True
  - id: auto_tare_value
    type: float
    initial_value: "0.0"
    restore_value: True
  - id: event_start
    type: time_t
    initial_value: "0"
    restore_value: False
  - id: stable_start
    type: time_t
    initial_value: "0"
    restore_value: False
  - id: stable_duration
    type: uint8_t
    initial_value: "0"
    restore_value: False
  - id: is_cat_event
    type: bool
    initial_value: "false"
    restore_value: False
  - id: litter_changed_date
    type: time_t
    initial_value: "0"
    restore_value: True
  - id: cat_weight_sum
    type: float
    initial_value: "0.0"
    restore_value: False
  - id: cat_weight_count
    type: int
    initial_value: "0"
    restore_value: False

esphome:
  name: litterbox
  friendly_name: Litterbox
  comment: Smart Litterbox
  project:
    name: "CristianChelu.LitterboxMonitor"
    version: "esp32.hx711"

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: ERROR

api:
  encryption:
    key: !secret litterbox_api_key
  services:
    - service: set_cat_weight
      variables:
        cat: int
        weight: float
      then:
        - lambda: !lambda |-
            switch(cat) {
              case 1: 
                id(cat1_weight) = weight;
                id(cat1_weight_sensor).publish_state(weight);
                return;
              case 2: 
                id(cat2_weight) = weight;
                id(cat2_weight_sensor).publish_state(weight);
                return;
            }

ota:
  - platform: esphome
    password: !secret litterbox_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Litterbox Fallback Hotspot"
    password: !secret litterbox_ap_password

captive_portal:

time:
  - platform: homeassistant
    timezone: ${timezone}
    id: homeassistant_time
    on_time:
      - hours: 0
        minutes: 0
        seconds: 0
        then:
          - lambda: !lambda |-
              id(cat1_daily_visits) = 0;
              id(cat1_daily_visits_sensor).publish_state(0);
              id(cat2_daily_visits) = 0;
              id(cat2_daily_visits_sensor).publish_state(0);

sensor:
  - platform: template
    name: "${cat1_name} Weight"
    id: cat1_weight_sensor
    icon: "mdi:scale-bathroom"
    device_class: weight
    state_class: measurement
    accuracy_decimals: 2
    unit_of_measurement: kg
    lambda: return id(cat1_weight);
  - platform: template
    name: "${cat2_name} Weight"
    id: cat2_weight_sensor
    icon: "mdi:scale-bathroom"
    device_class: weight
    state_class: measurement
    accuracy_decimals: 2
    unit_of_measurement: kg
    lambda: return id(cat2_weight);
  - platform: template
    name: "${cat1_name} Daily Visits"
    id: cat1_daily_visits_sensor
    icon: "mdi:eye-arrow-left"
    state_class: measurement
    accuracy_decimals: 0
    lambda: !lambda return id(cat1_daily_visits);
  - platform: template
    name: "${cat2_name} Daily Visits"
    id: cat2_daily_visits_sensor
    icon: "mdi:eye-arrow-left"
    state_class: measurement
    accuracy_decimals: 0
    lambda: !lambda return id(cat2_daily_visits);
  - platform: hx711
    id: hx711_raw_value
    name: "Raw sensor value"
    dout_pin: GPIO16
    clk_pin: GPIO4
    gain: 128
    update_interval: 100ms
    entity_category: diagnostic
    disabled_by_default: True
  - platform: copy
    id: hx711_calibrated_value
    source_id: hx711_raw_value
    unit_of_measurement: "kg"
    device_class: weight
    state_class: measurement
    accuracy_decimals: 3
    internal: true
    filters:
      - calibrate_linear: # FIXME: Set the calibration values for your HX711
          - 205901 -> 0.0
          - 1794742 -> 12.441
      - lambda: if (x > 40.0 || x < -20.0) { return {}; } else { return x; }
      - lambda: !lambda |-
          static float prev_value = 0.0;
          if (abs(x - prev_value) < ${spike_threshold}) {
            prev_value = x;
            return x;
          } else {
            prev_value = x;
            return {};
          }

  - platform: copy
    id: hx711_unfiltered_value
    name: "Unfiltered Weight"
    icon: "mdi:scale-unbalanced"
    entity_category: diagnostic
    source_id: hx711_calibrated_value
    internal: False
    disabled_by_default: True
    filters:
      # only publish raw 10hz sensor value during events
      - lambda: !lambda |-
          if (id(activity_detected).state) {
            return x;
          } else {
            return {};
          }

  - platform: copy
    id: hx711_filtered_value
    source_id: hx711_calibrated_value
    name: "Filtered Weight"
    icon: "mdi:scale-unbalanced"
    entity_category: diagnostic
    unit_of_measurement: "kg"
    accuracy_decimals: 3
    internal: False
    disabled_by_default: True
    filters:
      - quantile:
          window_size: 5
          send_every: 1
          send_first_at: 1
          quantile: 0.9
    on_value:
      - sensor.template.publish:
          id: tared_weight
          state: !lambda "return x - id(tare_value) - id(auto_tare_value);"
      - lambda: !lambda |- # Auto Tare
          if (abs(id(tared_weight).state) < 0.005 && id(activity_detected).state == false) {
            if (id(tared_weight).state != 0.0) {
              id(auto_tare_value) += id(tared_weight).state;
            }
          }
      - lambda: !lambda |- # Reading Stability
          static float prev_value = 0.0;
          if (abs(x - prev_value) < ${vibration_threshold}) {
            id(vibration_detected).publish_state(false);
          } else {
            id(vibration_detected).publish_state(true);
          }
          prev_value = x;
  - platform: template
    id: tared_weight
    name: "Tared Weight"
    icon: "mdi:scale"
    entity_category: diagnostic
    unit_of_measurement: "kg"
    accuracy_decimals: 3
    filters:
      - lambda: !lambda |-
          if (abs(x) < 0.001) {
            return 0.0;
          } else {
            return x;
          }
    on_value:
      - lambda: !lambda |- # Is a known cat
          bool is_cat_1 = abs(id(tared_weight).state - id(cat1_weight)) / id(cat1_weight) < 0.1;
          bool is_cat_2 = abs(id(tared_weight).state - id(cat2_weight)) / id(cat2_weight) < 0.1;
          if (is_cat_1 || is_cat_2) {
            id(cat_detected).publish_state(true);
          } else {
            id(cat_detected).publish_state(false);
          }
      - lambda: !lambda |- # Average stable cat weight
          if (id(cat_detected).state == true && id(vibration_detected).state == false) {
            id(cat_weight_count) = id(cat_weight_count) + 1;
            id(cat_weight_sum) = id(cat_weight_sum) + id(tared_weight).state;
          }
  - platform: template
    unit_of_measurement: g
    name: "Waste Weight"
    id: waste_weight
    accuracy_decimals: 0
    icon: "mdi:emoticon-poop"
  - platform: template
    name: "Cat Weight"
    id: current_cat_weight
    entity_category: diagnostic
    accuracy_decimals: 2
    unit_of_measurement: kg
    icon: "mdi:scale-bathroom"
    disabled_by_default: True
  - platform: template
    unit_of_measurement: kg
    id: litter_weight
    name: "Litter Remaining"
    icon: "mdi:tray-full"
    accuracy_decimals: 2
  - platform: template
    name: "Visits since clean"
    id: visits
    accuracy_decimals: 0
    update_interval: never
    state_class: measurement
  - platform: template
    name: "Litterbox Weight"
    icon: "mdi:tray"
    device_class: weight
    unit_of_measurement: kg
    entity_category: diagnostic
    lambda: return id(litterbox_weight);
    disabled_by_default: True
  - platform: template
    id: litter_life_left
    name: "Deep Clean Timer"
    icon: mdi:broom
    device_class: duration
    state_class: measurement
    unit_of_measurement: "d"
    accuracy_decimals: 0
    lambda: !lambda |-
      auto last_changed = id(litter_changed_date);
      if (last_changed == 0) {
        return 0;
      }

      const double seconds_per_day = 60 * 60 * 24;
      double now = id(homeassistant_time).now().timestamp;
      double dur = last_changed + (${litter_change_interval} * seconds_per_day) - now;
      return std::max(std::floor(dur / seconds_per_day), (double)0);

binary_sensor:
  - platform: analog_threshold
    sensor_id: tared_weight
    name: "Occupancy"
    device_class: occupancy
    entity_category: diagnostic
    id: occupancy_detected
    disabled_by_default: True
    threshold:
      lower: 0.6
      upper: 0.9
  - platform: template
    name: "Activity"
    id: activity_detected
    entity_category: diagnostic
    device_class: motion
    lambda: return id(cat_detected).state || id(vibration_detected).state || id(occupancy_detected).state;
    filters:
      - delayed_off:
          seconds: ${activity_off_delay}
    on_press:
      - lambda: !lambda |-
          id(event_start) = id(homeassistant_time).now().timestamp; 
          ESP_LOGV("ACT", "Activity start! %lu", id(event_start));
    on_release:
      - lambda: !lambda |- # Set cat event data
          // TODO: Revisit logic.
          // Figure out how to distinguish between cat playing nearby
          // and cat actually using the litterbox to add a visit correctly.
          // This might not be necessary because if a cat attempts to use
          // the litterbox (i.e. crouch and stay still), the vibration 
          // sensor would trigger a stable weight reading.

          // Update cat weight if stable enough
          if (id(current_cat_weight).state > 0.0) {
            bool is_cat_1 = abs(id(current_cat_weight).state - id(cat1_weight)) / id(cat1_weight) < 0.1;
            bool is_cat_2 = abs(id(current_cat_weight).state - id(cat2_weight)) / id(cat2_weight) < 0.1;
            if (is_cat_1) {
              id(cat1_weight) = id(current_cat_weight).state;
              id(cat1_weight_sensor).publish_state(id(current_cat_weight).state);
              id(cat1_daily_visits) = id(cat1_daily_visits) + 1;
              id(cat1_daily_visits_sensor).publish_state(id(cat1_daily_visits));
            } else if (is_cat_2) {
              id(cat2_weight) = id(current_cat_weight).state;
              id(cat2_weight_sensor).publish_state(id(current_cat_weight).state);
              id(cat2_daily_visits) = id(cat2_daily_visits) + 1;
              id(cat2_daily_visits_sensor).publish_state(id(cat2_daily_visits));
            }

            // Add to total waste in litterbox if the cat was stable enough to leave something
            id(waste_weight).publish_state(id(waste_weight).state + max(id(tared_weight).state * 1000, 0.0f));
          }

          if (id(is_cat_event)) {
            // Add a visit even if the cat left nothing
            id(visits).publish_state(id(visits).state + 1);
          }
      - lambda: !lambda |- # Set clean event data
          if (id(is_cat_event)) {
            return;
          }
          auto now = id(homeassistant_time).now().timestamp;
          if (now - id(event_start) < ${min_clean_event_duration}) {
            // ignore bumps
            // TODO: Figure out from vibration pattern what makes a clean event
            return;
          }

          id(litter_weight).publish_state(id(hx711_filtered_value).state - id(litterbox_weight));
          id(waste_weight).publish_state(0.0);
          id(visits).publish_state(0);
      - script.execute: reset_event
  - platform: template
    device_class: vibration
    entity_category: diagnostic
    name: "Vibration"
    id: vibration_detected
    disabled_by_default: True
    filters:
      - delayed_off:
          seconds: ${vibration_off_delay}
    on_press:
      - script.execute: countdown_inactivity_timeout
      - lambda: !lambda |- # Longest stable duration
          if (id(is_cat_event) == false) {
            return;
          }
          time_t now = id(homeassistant_time).now().timestamp;
          uint8_t dur = now - id(stable_start) + ${vibration_off_delay};
          ESP_LOGV("VBR", "Vibration start! duration: %u, max dur: %u", dur, id(stable_duration));
          if (dur > id(stable_duration)) {
            id(stable_duration) = dur;
            
            // Cat weight is average of longest stable duration
            if (id(cat_weight_count) > 0) {
              id(current_cat_weight).publish_state(id(cat_weight_sum)/id(cat_weight_count));
              ESP_LOGV("VBR", "Publishing cat state: %.2f", id(cat_weight_sum)/id(cat_weight_count));
            }
          }
          id(cat_weight_sum) = 0;
          id(cat_weight_count) = 0;
    on_release:
      - script.stop: countdown_inactivity_timeout
      - lambda: !lambda |-
          ESP_LOGV("VBR", "Vibration end! eventStart: %lu", id(event_start));
          if (id(event_start) == 0) {
            return;
          }
          id(stable_start) = id(homeassistant_time).now().timestamp;

  - platform: template
    device_class: occupancy
    entity_category: diagnostic
    name: "Cat Event"
    id: cat_detected
    disabled_by_default: True
    filters:
      - delayed_on:
          seconds: 2
    on_press:
      - lambda: id(is_cat_event) = true;

button:
  - platform: template
    name: "Reset Deep Clean Timer"
    icon: mdi:reload
    on_press:
      - lambda: !lambda |-
          id(litter_changed_date) = id(homeassistant_time).now().timestamp;
      - sensor.template.publish:
          id: litter_life_left
          state: ${litter_change_interval}
  - platform: template
    name: "Reset Clean"
    icon: mdi:reload
    on_press:
      - script.execute: reset_event
      - lambda: !lambda |-
          id(waste_weight).publish_state(0);
          id(visits).publish_state(0);
          id(litter_weight).publish_state(id(hx711_filtered_value).state - id(litterbox_weight));

script:
  # Reset all event-related state
  - id: reset_event
    then:
     logger.log:
          level: DEBUG
          format: "Resetting event state"
      - script.stop: countdown_inactivity_timeout
      - lambda: !lambda |-
          id(cat_detected).publish_state(false);
          id(current_cat_weight).publish_state(0);
          id(tare_value) = id(hx711_filtered_value).state;
          id(auto_tare_value) = 0;
          id(is_cat_event) = false;
          id(event_start) = 0;
          id(stable_start) = 0;
          id(stable_duration) = 0;
          id(cat_weight_count) = 0;
          id(cat_weight_sum) = 0;
  # Begin a countdown for inactivity timeout
  - id: countdown_inactivity_timeout
    then:
      - delay: ${inactivity_timeout}s
      - logger.log:
          level: INFO
          format: "Event timeout after ${inactivity_timeout}s of inactivity"
      - script.execute: reset_event
